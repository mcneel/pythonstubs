from typing import Tuple, Set, Iterable, List


class Circle2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Circle2): ...
    @overload
    def __init__(self, origin: Node2, radius: float): ...
    @overload
    def __init__(self, A: Node2, B: Node2, C: Node2): ...
    def Circle3Pt(ax: float, ay: float, bx: float, by: float, cx: float, cy: float, ox: float, oy: float, r2: float) -> Tuple[bool, float, float, float]: ...
    @overload
    def ClosestPointTo(self, pt: Node2) -> float: ...
    @overload
    def ClosestPointTo(self, x: float, y: float) -> float: ...
    @overload
    def ClosestPointTo(self, pt: Node2, t: float) -> Tuple[Node2, float]: ...
    @overload
    def ClosestPointTo(self, x: float, y: float, t: float) -> Tuple[Node2, float]: ...
    @overload
    def Contains(self, pt: Node2) -> Containment: ...
    @overload
    def Contains(self, x: float, y: float) -> Containment: ...
    def Duplicate(self) -> Circle2: ...
    @property
    def Area(self) -> float: ...
    @property
    def Circumference(self) -> float: ...
    @overload
    def Intersect(self, line: Line2, l0: float, l1: float) -> Tuple[LineCircleX, float, float]: ...
    @overload
    def Intersect(self, line: Line2, l0: float, l1: float, a0: float, a1: float) -> Tuple[LineCircleX, float, float, float, float]: ...
    def PointAt(self, t: float) -> Node2: ...
    def TangentAt(self, t: float) -> Vec2: ...


class Containment:
    none = 0
    inside = 1
    coincident = 2
    outside = 3


class GH_CurveOffset:
    @overload
    def __init__(self, curve: Curve, offsetPlane: Plane): ...
    @overload
    def __init__(self, curves: Iterable[Curve], offsetPlane: Plane): ...
    @property
    def OffsetPlane(self) -> Plane: ...
    def Offset(self, distance: float, corner: GH_CurveOffsetCorner) -> List: ...
    def OffsetSamples(self, distance: float) -> List: ...


class GH_CurveOffsetCorner:
    Chamfer = 0
    Sharp = 1
    Fillet = 2


class GH_SanityXForm:
    def __init__(self): ...
    def CreateSanityXForms(self, box: BoundingBox) -> bool: ...
    @overload
    def MakeInsane(self, geometry: GeometryBase) -> None: ...
    @overload
    def MakeInsane(self, geometry: IGH_GeometricGoo) -> Tuple[IGH_GeometricGoo]: ...
    @overload
    def MakeInsane(self, geometry: Point3d) -> Tuple[Point3d]: ...
    @overload
    def MakeInsane(self, geometry: Plane) -> Tuple[Plane]: ...
    @overload
    def MakeSane(self, geometry: GeometryBase) -> None: ...
    @overload
    def MakeSane(self, geometry: IGH_GeometricGoo) -> Tuple[IGH_GeometricGoo]: ...
    @overload
    def MakeSane(self, geometry: Point3d) -> Tuple[Point3d]: ...
    @overload
    def MakeSane(self, geometry: Plane) -> Tuple[Plane]: ...


class ILeafAction:
    def LeafAction(self, Leaf: Node2Leaf) -> VorLeafRecursionResult: ...


class ILeafAction:
    def LeafAction(self, Leaf: Node3Leaf) -> VorLeafRecursionResult: ...


class LeafAction:
    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...
    def BeginInvoke(self, Leaf: Node3Leaf, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...
    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> VorLeafRecursionResult: ...
    def Invoke(self, Leaf: Node3Leaf) -> VorLeafRecursionResult: ...


class LeafAction:
    def __init__(self, TargetObject: Object, TargetMethod: IntPtr): ...
    def BeginInvoke(self, Leaf: Node2Leaf, DelegateCallback: AsyncCallback, DelegateAsyncState: Object) -> IAsyncResult: ...
    def EndInvoke(self, DelegateAsyncResult: IAsyncResult) -> VorLeafRecursionResult: ...
    def Invoke(self, Leaf: Node2Leaf) -> VorLeafRecursionResult: ...


class Line2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Line2): ...
    @overload
    def __init__(self, nA: Node2, nB: Node2): ...
    @overload
    def __init__(self, nAx: float, nAy: float, nBx: float, nBy: float): ...
    @overload
    def ClosestPoint(self, pt: Node2) -> float: ...
    @overload
    def ClosestPoint(self, x: float, y: float) -> float: ...
    @overload
    def DistanceTo(self, pt: Node2) -> float: ...
    @overload
    def DistanceTo(self, x: float, y: float) -> float: ...
    @overload
    def DistanceToSquared(self, pt: Node2) -> float: ...
    @overload
    def DistanceToSquared(self, x: float, y: float) -> float: ...
    def Duplicate(self) -> Line2: ...
    @overload
    def Intersect(A: Line2, B: Line2, t: float) -> Tuple[LineX, float]: ...
    @overload
    def Intersect(A: Line2, B: Line2, t0: float, t1: float) -> Tuple[LineX, float, float]: ...
    @overload
    def Intersect(Ax: float, Ay: float, Bx: float, By: float, Cx: float, Cy: float, Dx: float, Dy: float, t: float) -> Tuple[LineX, float]: ...
    @overload
    def Intersect(Ax: float, Ay: float, Bx: float, By: float, Cx: float, Cy: float, Dx: float, Dy: float, t0: float, t1: float) -> Tuple[LineX, float, float]: ...
    def Length(self) -> float: ...
    def LengthSquared(self) -> float: ...
    @overload
    def MidLine(A: Node2, B: Node2) -> Line2: ...
    @overload
    def MidLine(A: Node2, B: Node2, Wa: float, Wb: float) -> Line2: ...
    def PointAt(self, t: float) -> Node2: ...
    @overload
    def Set(self, other: Line2) -> None: ...
    @overload
    def Set(self, A: Node2, B: Node2) -> None: ...
    @overload
    def Side(edge: Line2, pt: Node2) -> Side2: ...
    @overload
    def Side(Ax: float, Ay: float, Bx: float, By: float, Px: float, Py: float) -> Side2: ...


class Line3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Line3): ...
    @overload
    def __init__(self, nA: Node3, nB: Node3): ...
    @overload
    def __init__(self, nAx: float, nAy: float, nAz: float, nBx: float, nBy: float, nBz: float): ...
    @overload
    def ClosestPoint(self, pt: Node3) -> float: ...
    @overload
    def ClosestPoint(self, x: float, y: float, z: float) -> float: ...
    @overload
    def DistanceTo(self, pt: Node3) -> float: ...
    @overload
    def DistanceTo(self, x: float, y: float, z: float) -> float: ...
    @overload
    def DistanceToSquared(self, pt: Node3) -> float: ...
    @overload
    def DistanceToSquared(self, x: float, y: float, z: float) -> float: ...
    def Duplicate(self) -> Line3: ...
    @overload
    def Intersect(A: Line3, B: Line3, t: float) -> Tuple[LineX, float]: ...
    @overload
    def Intersect(A: Line3, B: Line3, t0: float, t1: float) -> Tuple[LineX, float, float]: ...
    @overload
    def Intersect(Ax: float, Ay: float, Az: float, Bx: float, By: float, Bz: float, Cx: float, Cy: float, Cz: float, Dx: float, Dy: float, Dz: float, t: float) -> Tuple[LineX, float]: ...
    @overload
    def Intersect(Ax: float, Ay: float, Az: float, Bx: float, By: float, Bz: float, Cx: float, Cy: float, Cz: float, Dx: float, Dy: float, Dz: float, t0: float, t1: float) -> Tuple[LineX, float, float]: ...
    def Length(self) -> float: ...
    def LengthSquared(self) -> float: ...
    def PointAt(self, t: float) -> Node3: ...
    @overload
    def Set(self, other: Line3) -> None: ...
    @overload
    def Set(self, A: Node3, B: Node3) -> None: ...


class LineCircleX:
    #None = 0
    Tangent = 1
    Secant = 2


class LineX:
    #None = 0
    Parallel = 1
    Coincident = 2
    Point = 3


class Node2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node2): ...
    @overload
    def __init__(self, nx: float, ny: float): ...
    @overload
    def __init__(self, nx: float, ny: float, n_tag: int): ...
    @overload
    def __init__(self, other: Node2, dx: float, dy: float): ...
    @overload
    def __init__(self, A: Node2, B: Node2, f: float, n_tag: int): ...
    @overload
    def CompareTo(self, other: Node2) -> int: ...
    @overload
    def CompareTo(self, other: Node2, tolerance: float) -> int: ...
    @overload
    def Distance(self, other: Node2) -> float: ...
    @overload
    def Distance(self, nx: float, ny: float) -> float: ...
    @overload
    def DistanceSquared(self, other: Node2) -> float: ...
    @overload
    def DistanceSquared(self, nx: float, ny: float) -> float: ...
    def Duplicate(self) -> Node2: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def IsCoincident(self, other: Node2) -> bool: ...
    @overload
    def IsCoincident(self, ox: float, oy: float) -> bool: ...
    def Offset(self, dx: float, dy: float) -> None: ...
    @overload
    def op_Addition(P: Node2, V: Vec2) -> Node2: ...
    @overload
    def op_Addition(A: Node2, B: Node2) -> Node2: ...
    @overload
    def op_Multiply(f: float, N: Node2) -> Node2: ...
    @overload
    def op_Multiply(N: Node2, f: float) -> Node2: ...
    @overload
    def op_Subtraction(P: Node2, V: Vec2) -> Node2: ...
    @overload
    def op_Subtraction(A: Node2, B: Node2) -> Vec2: ...
    @overload
    def Set(self, other: Node2) -> None: ...
    @overload
    def Set(self, nX: float, nY: float) -> None: ...
    def ToString(self) -> str: ...


class Node2Leaf:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node2Leaf): ...
    @overload
    def __init__(self, x0: float, x1: float, y0: float, y1: float): ...
    def Contains(self, x: float, y: float) -> bool: ...
    @property
    def A(self) -> Node2Leaf: ...
    @property
    def B(self) -> Node2Leaf: ...
    @property
    def C(self) -> Node2Leaf: ...
    @property
    def D(self) -> Node2Leaf: ...
    @property
    def Nodes(self) -> List: ...
    @property
    def SubLeafCount(self) -> int: ...
    @property
    def x_max(self) -> float: ...
    @property
    def x_mid(self) -> float: ...
    @property
    def x_min(self) -> float: ...
    @property
    def y_max(self) -> float: ...
    @property
    def y_mid(self) -> float: ...
    @property
    def y_min(self) -> float: ...
    def MaximumDistance(self, x: float, y: float) -> float: ...
    def MaximumDistanceSquared(self, x: float, y: float) -> float: ...
    def MinimumDistance(self, x: float, y: float) -> float: ...
    def MinimumDistanceSquared(self, x: float, y: float) -> float: ...
    @overload
    def PerformLeafAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformLeafAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    def SolveProximity(self, nodes: Node2List, prox: Node2Proximity) -> None: ...
    def SubDivide(self, nodes: Node2List, index_subset: List, group_limit: int) -> None: ...


class Node2List:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, L: Iterable[Node2]): ...
    @overload
    def __init__(self, L: Node2List): ...
    @overload
    def __init__(self, pts: Iterable[GH_Point]): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    def Append(self, node: Node2) -> None: ...
    def AppendRange(self, nodes: Iterable[Node2]) -> None: ...
    def BinarySearch_I(self, i: int) -> int: ...
    def BinarySearch_X(self, x: float) -> int: ...
    def BinarySearch_Y(self, y: float) -> int: ...
    def BoundingBox(self, GrowthFactor: float, ForceSquareLeaves: bool, x0: float, x1: float, y0: float, y1: float) -> Tuple[bool, float, float, float, float]: ...
    def CreateTree(self, GrowthFactor: float, SquareLeaves: bool, GroupLimit: int) -> Node2Tree: ...
    def CullDuplicates(self) -> int: ...
    def CullNullRefs(self) -> int: ...
    def ExpireSequence(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def InternalList(self) -> List: ...
    @property
    def Node(self, i: int) -> Node2: ...
    def GetEnumerator(self) -> IEnumerator: ...
    def GetEnumerator1(self) -> IEnumerator: ...
    def Insert(self, index: int, node: Node2) -> None: ...
    def InsertRange(self, index: int, nodes: Iterable[Node2]) -> None: ...
    def JitterNodes(self, amount: float) -> None: ...
    def NearestNodes(self, x: float, y: float, N: int, min_dist_squared: float, max_dist_squared: float) -> List: ...
    def NullifyDuplicates(self) -> int: ...
    def Remove(self, node: Node2) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def RenumberNodes(self) -> None: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @InternalList.setter
    def InternalList(self, Value: List) -> None: ...
    @Node.setter
    def Node(self, i: int, Value: Node2) -> None: ...
    def Sort(self, type: NodeListSort) -> None: ...


class Node2Proximity:
    @overload
    def __init__(self, search_start: Node2, search_start_index: int): ...
    @overload
    def __init__(self, search_start: Node2, search_start_index: int, max_results: int): ...
    @overload
    def __init__(self, search_start: Node2, search_start_index: int, max_results: int, min_distance: float, max_distance: float): ...
    def DistanceRange(self, d0: float, d1: float) -> Tuple[float, float]: ...
    @property
    def CurrentCount(self) -> int: ...
    @property
    def DistanceList(self) -> List: ...
    @property
    def FurthestDistance(self) -> float: ...
    @property
    def FurthestDistanceSquared(self) -> float: ...
    @property
    def FurthestPoint(self) -> int: ...
    @property
    def IndexList(self) -> List: ...
    @property
    def MaximumCount(self) -> int: ...
    @property
    def MaxSearchRadius(self) -> float: ...
    @property
    def MaxSearchRadiusSquared(self) -> float: ...
    @property
    def MinSearchRadius(self) -> float: ...
    @property
    def MinSearchRadiusSquared(self) -> float: ...
    @property
    def NearestDistance(self) -> float: ...
    @property
    def NearestDistanceSquared(self) -> float: ...
    @property
    def NearestPoint(self) -> int: ...
    @property
    def Start(self) -> Node2: ...
    @property
    def StartIndex(self) -> int: ...
    def RegisterNode(self, node: Node2, index: int) -> bool: ...
    def ResetLists(self) -> None: ...


class Node2Tree:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, owner: Node2List): ...
    @overload
    def PerformAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    def RecreateTree(self, GrowthFactor: float, ForceSquareLeaves: bool, GroupLimit: int) -> bool: ...
    def SolveProximity(self, prox: Node2Proximity) -> None: ...


class Node3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node3): ...
    @overload
    def __init__(self, other: Point3d, nI: int): ...
    @overload
    def __init__(self, other: Point3f, nI: int): ...
    @overload
    def __init__(self, nX: float, nY: float, nZ: float, nI: int): ...
    def Coincident(self, other: Node3) -> bool: ...
    def CoincidentFlat(self, other: Node3) -> bool: ...
    def CompareTo(self, other: Node3) -> int: ...
    @overload
    def Distance(self, other: Node3) -> float: ...
    @overload
    def Distance(self, ox: float, oy: float, oz: float) -> float: ...
    @overload
    def DistanceSquared(self, other: Node3) -> float: ...
    @overload
    def DistanceSquared(self, ox: float, oy: float, oz: float) -> float: ...
    def Duplicate(self) -> Node3: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    def Offset(self, dx: float, dy: float, dz: float) -> None: ...
    def op_Addition(P: Node3, V: Vec3) -> Node3: ...
    def op_Subtraction(A: Node3, B: Node3) -> Vec3: ...
    @overload
    def Set(self, other: Node3) -> None: ...
    @overload
    def Set(self, nX: float, nY: float, nZ: float) -> None: ...
    def ToString(self) -> str: ...


class Node3Leaf:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Node3Leaf): ...
    @overload
    def __init__(self, x0: float, x1: float, y0: float, y1: float, z0: float, z1: float): ...
    def Contains(self, x: float, y: float, z: float) -> bool: ...
    @property
    def A(self) -> Node3Leaf: ...
    @property
    def B(self) -> Node3Leaf: ...
    @property
    def C(self) -> Node3Leaf: ...
    @property
    def D(self) -> Node3Leaf: ...
    @property
    def E(self) -> Node3Leaf: ...
    @property
    def F(self) -> Node3Leaf: ...
    @property
    def G(self) -> Node3Leaf: ...
    @property
    def H(self) -> Node3Leaf: ...
    @property
    def Nodes(self) -> List: ...
    @property
    def SubLeafCount(self) -> int: ...
    @property
    def x_max(self) -> float: ...
    @property
    def x_mid(self) -> float: ...
    @property
    def x_min(self) -> float: ...
    @property
    def y_max(self) -> float: ...
    @property
    def y_mid(self) -> float: ...
    @property
    def y_min(self) -> float: ...
    @property
    def z_max(self) -> float: ...
    @property
    def z_mid(self) -> float: ...
    @property
    def z_min(self) -> float: ...
    def MaximumDistance(self, x: float, y: float, z: float) -> float: ...
    def MaximumDistanceSquared(self, x: float, y: float, z: float) -> float: ...
    def MinimumDistance(self, x: float, y: float, z: float) -> float: ...
    def MinimumDistanceSquared(self, x: float, y: float, z: float) -> float: ...
    @overload
    def PerformLeafAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformLeafAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def RemoveNode(self, nodes: Node3List, nodeTag: int) -> bool: ...
    @overload
    def RemoveNode(self, nodes: Node3List, node: Node3) -> bool: ...
    def SolveProximity(self, nodes: Node3List, prox: Node3Proximity) -> None: ...
    def SubDivide(self, nodes: Node3List, index_subset: List, group_limit: int) -> None: ...
    def TrimExcess(self) -> None: ...


class Node3List:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, L: Iterable[Node3]): ...
    @overload
    def __init__(self, L: Node3List): ...
    @overload
    def __init__(self, pts: Iterable[GH_Point]): ...
    @overload
    def __init__(self, pts: Iterable[Point3d]): ...
    def Append(self, node: Node3) -> None: ...
    def AppendRange(self, nodes: Iterable[Node3]) -> None: ...
    def BinarySearch_I(self, i: int) -> int: ...
    def BinarySearch_X(self, x: float) -> int: ...
    def BinarySearch_Y(self, y: float) -> int: ...
    def BinarySearch_Z(self, z: float) -> int: ...
    def BoundingBox(self, GrowthFactor: float, ForceSquareLeaves: bool, x0: float, x1: float, y0: float, y1: float, z0: float, z1: float) -> Tuple[bool, float, float, float, float, float, float]: ...
    def Clear(self) -> None: ...
    def CreateTree(self, GrowthFactor: float, SquareLeaves: bool, GroupLimit: int) -> Node3Tree: ...
    def CullDuplicates(self) -> int: ...
    def CullNullRefs(self) -> int: ...
    def ExpireSequence(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @property
    def Count(self) -> int: ...
    @property
    def InternalList(self) -> List: ...
    @property
    def Node(self, i: int) -> Node3: ...
    def Insert(self, index: int, node: Node3) -> None: ...
    def InsertRange(self, index: int, nodes: Iterable[Node3]) -> None: ...
    def JitterNodes(self, amount: float) -> None: ...
    def NearestNodes(self, x: float, y: float, z: float, N: int, min_dist_squared: float, max_dist_squared: float) -> List: ...
    def NullifyDuplicates(self) -> int: ...
    def Remove(self, node: Node3) -> bool: ...
    def RemoveAt(self, index: int) -> None: ...
    def RenumberNodes(self) -> None: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @InternalList.setter
    def InternalList(self, Value: List) -> None: ...
    @Node.setter
    def Node(self, i: int, Value: Node3) -> None: ...
    def Sort(self, type: NodeListSort) -> None: ...


class Node3Proximity:
    @overload
    def __init__(self, search_start: Node3, search_start_index: int): ...
    @overload
    def __init__(self, search_start: Node3, search_start_index: int, max_results: int): ...
    @overload
    def __init__(self, search_start: Node3, search_start_index: int, max_results: int, min_distance: float, max_distance: float): ...
    def DistanceRange(self, d0: float, d1: float) -> Tuple[float, float]: ...
    @property
    def CurrentCount(self) -> int: ...
    @property
    def DistanceList(self) -> List: ...
    @property
    def FurthestDistance(self) -> float: ...
    @property
    def FurthestDistanceSquared(self) -> float: ...
    @property
    def FurthestPoint(self) -> int: ...
    @property
    def IndexList(self) -> List: ...
    @property
    def MaximumCount(self) -> int: ...
    @property
    def MaxSearchRadius(self) -> float: ...
    @property
    def MaxSearchRadiusSquared(self) -> float: ...
    @property
    def MinSearchRadius(self) -> float: ...
    @property
    def MinSearchRadiusSquared(self) -> float: ...
    @property
    def NearestDistance(self) -> float: ...
    @property
    def NearestDistanceSquared(self) -> float: ...
    @property
    def NearestPoint(self) -> int: ...
    @property
    def Start(self) -> Node3: ...
    @property
    def StartIndex(self) -> int: ...
    def RegisterNode(self, node: Node3, index: int) -> bool: ...
    def ResetLists(self) -> None: ...


class Node3Tree:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, owner: Node3List): ...
    @property
    def Root(self) -> Node3Leaf: ...
    @overload
    def PerformAction(self, func: LeafAction, call_on_empty_leaves: bool) -> None: ...
    @overload
    def PerformAction(self, func: ILeafAction, call_on_empty_leaves: bool) -> None: ...
    def RecreateTree(self, growthFactor: float, squareLeaves: bool, groupLimit: int) -> bool: ...
    def SolveProximity(self, prox: Node3Proximity) -> None: ...


class NodeListSort:
    none = 0
    X = 1
    Y = 2
    Z = 3
    Index = 4


class NodeListSort:
    none = 0
    X = 1
    Y = 2
    Index = 3


class Parallax:
    Divergent = 0
    Parallel = 1
    AntiParallel = -1


class Plane:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, nOrigin: Node3, nNormal: Vec3): ...
    @overload
    def __init__(self, nOrigin: Node3, nXAxis: Vec3, nYAxis: Vec3): ...
    @overload
    def __init__(self, nOrigin: Node3, nXAxis: Vec3, nYAxis: Vec3, nZAxis: Vec3): ...
    @property
    def World_XY() -> Plane: ...
    @overload
    def PointAt(self, u: float, v: float) -> Node3: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Node3: ...
    @overload
    def Project(self, pt: Node3) -> None: ...
    @overload
    def Project(self, pts: List[Node3]) -> None: ...
    @overload
    def Project(self, pt: Node3, s: float, t: float) -> Tuple[float, float]: ...
    def Unitize(self) -> None: ...


class PointCloud:
    def __init__(self): ...
    def InsertPoint(self, pt: Point3d) -> int: ...


class Rectangle2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, p0: Node2, p1: Node2): ...
    @overload
    def __init__(self, x0: float, y0: float, x1: float, y1: float): ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def Grow(self, pt: Node2) -> None: ...
    @overload
    def Grow(self, rec: Rectangle2) -> None: ...
    @overload
    def Grow(self, x: float, y: float) -> None: ...
    @overload
    def Includes(self, pt: Node2) -> Containment: ...
    @overload
    def Includes(self, x: float, y: float) -> Containment: ...
    def Intersect(self, line: Line2) -> Node2: ...
    def MakeIncreasing(self) -> None: ...
    @overload
    def ParameterAt(self, pt: Node2) -> Node2: ...
    @overload
    def ParameterAt(self, x: float, y: float) -> Node2: ...
    def PointAt(self, x: float, y: float) -> Node2: ...


class Region2:
    def __init__(self, nodes: Iterable[Node2]): ...
    def Contains(self, node: Node2) -> bool: ...


class SamplingRegion:
    def __init__(self, regions: Iterable[Curve]): ...
    def Dispose(self) -> None: ...


class Side2:
    Coincident = 0
    Right = 1
    Left = -1


class Vec2:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Vec2): ...
    @overload
    def __init__(self, other: Vector2d): ...
    @overload
    def __init__(self, other: Vector2f): ...
    @overload
    def __init__(self, nX: float, nY: float): ...
    def CompareTo(self, other: Vec2) -> int: ...
    def CreatePerpendicular(self) -> Vec2: ...
    def Duplicate(self) -> Vec2: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Unit_X() -> Vec2: ...
    @property
    def Unit_Y() -> Vec2: ...
    def Length(self) -> float: ...
    def LengthSquared(self) -> float: ...
    def op_Addition(A: Vec2, B: Vec2) -> Vec2: ...
    def op_Multiply(V: Vec2, F: float) -> Vec2: ...
    def op_Subtraction(A: Vec2, B: Vec2) -> Vec2: ...
    @overload
    def ParallelTo(self, v: Vec2) -> Parallax: ...
    @overload
    def ParallelTo(self, v: Vec2, angle_tol: float) -> Parallax: ...
    @overload
    def PerpendicularTo(self, v: Vec2) -> bool: ...
    @overload
    def PerpendicularTo(self, v: Vec2, angle_tol: float) -> bool: ...
    @overload
    def Set(self, other: Vec2) -> None: ...
    @overload
    def Set(self, nX: float, nY: float) -> None: ...
    def ToString(self) -> str: ...
    def Unitize(self) -> None: ...


class Vec3:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: Vec3): ...
    @overload
    def __init__(self, other: Vector3d): ...
    @overload
    def __init__(self, other: Vector3f): ...
    @overload
    def __init__(self, nX: float, nY: float, nZ: float): ...
    def CompareTo(self, other: Vec3) -> int: ...
    def CreatePerpendicular(self) -> Vec3: ...
    @overload
    def CrossProduct(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    def CrossProduct(ax: float, ay: float, az: float, bx: float, by: float, bz: float) -> Vec3: ...
    def Duplicate(self) -> Vec3: ...
    @property
    def DebuggerDisplay(self) -> str: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Unit_X() -> Vec3: ...
    @property
    def Unit_Y() -> Vec3: ...
    @property
    def Unit_Z() -> Vec3: ...
    def Length(self) -> float: ...
    def LengthFlat(self) -> float: ...
    def LengthSquared(self) -> float: ...
    def LengthSquaredFlat(self) -> float: ...
    def op_Addition(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    def op_Multiply(V: Vec3, F: float) -> Vec3: ...
    @overload
    def op_Multiply(A: Vec3, B: Vec3) -> float: ...
    def op_Subtraction(A: Vec3, B: Vec3) -> Vec3: ...
    @overload
    def ParallelTo(self, v: Vec3) -> Parallax: ...
    @overload
    def ParallelTo(self, v: Vec3, angle_tol: float) -> Parallax: ...
    @overload
    def PerpendicularTo(self, v: Vec3) -> bool: ...
    @overload
    def PerpendicularTo(self, v: Vec3, angle_tol: float) -> bool: ...
    @overload
    def Set(self, other: Vec3) -> None: ...
    @overload
    def Set(self, nX: float, nY: float, nZ: float) -> None: ...
    def ToString(self) -> str: ...
    def Unitize(self) -> None: ...


class VorLeafRecursionResult:
    Continue = 0
    Abort = -1


class VorLeafRecursionResult:
    Continue = 0
    Abort = -1
