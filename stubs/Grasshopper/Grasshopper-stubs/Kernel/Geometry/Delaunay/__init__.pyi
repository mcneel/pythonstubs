from typing import Tuple, Set, Iterable, List


class Face:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, nA: int, nB: int, nC: int): ...
    @overload
    def __init__(self, other: Face): ...
    def Duplicate(self) -> Face: ...
    @overload
    def Set(self, nA: int, nB: int, nC: int) -> None: ...
    @overload
    def Set(self, other: Face) -> None: ...
    @property
    def IsValid(self) -> bool: ...
    def ContainsVertex(self, index: int) -> bool: ...
    def ContainsEdge(self, E0: int, E1: int) -> bool: ...
    @property
    def DebuggerDisplay(self) -> str: ...


class FaceEx(Face):
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, nA: int, nB: int, nC: int): ...
    @overload
    def __init__(self, other: Face): ...
    @overload
    def ComputeBC(self, Nodes: Node2List) -> None: ...
    @overload
    def ComputeBC(self, D: Node2, E: Node2, F: Node2) -> None: ...
    @property
    def Front(self) -> float: ...
    @overload
    def ContainsInBoundingCircle(self, N: Node2) -> bool: ...
    @overload
    def ContainsInBoundingCircle(self, x: float, y: float) -> bool: ...


class FaceExList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initial_capacity: int): ...
    def Clear(self) -> None: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @overload
    def AddFace(self, A: int, B: int, C: int, Nodes: Node2List) -> None: ...
    @overload
    def AddFace(self, F: FaceEx) -> None: ...
    def CullFaces(self, x: float, y: float, F: List) -> int: ...
    def MigrateRemainingFaces(self, static_list: List) -> None: ...
    def MigrateStaticFaces(self, static_list: List, wave_front: float) -> int: ...
    def TrimNulls(self) -> int: ...
    def InsertFaces(self, nodes: Node2List) -> None: ...


class Edge:
    def __init__(self, nA: int, nB: int, nN: int): ...
    def CompareTo(self, other: Edge) -> int: ...
    @property
    def DebuggerDisplay(self) -> str: ...


class EdgeList:
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, F: List): ...
    @overload
    def __init__(self, F: List): ...
    @property
    def Edge(self, index: int) -> Edge: ...
    @property
    def Capacity(self) -> int: ...
    @Capacity.setter
    def Capacity(self, Value: int) -> None: ...
    @property
    def Count(self) -> int: ...
    def Clear(self) -> None: ...
    @overload
    def AddEdge(self, A: int, B: int) -> None: ...
    @overload
    def AddEdge(self, E: Edge) -> None: ...
    @overload
    def RemoveEdge(self, A: int, B: int) -> bool: ...
    @overload
    def RemoveEdge(self, E: Edge) -> bool: ...
    @overload
    def ContainsEdge(self, A: int, B: int) -> int: ...
    @overload
    def ContainsEdge(self, E: Edge) -> int: ...
    def TrimHighValenceEdges(self) -> int: ...


class Connectivity:
    def __init__(self): ...
    def SolveConnectivity(self, nodes: Node2List, faces: List, include_convex_hull_edges: bool) -> None: ...
    def GetConnections(self, node_index: int) -> List: ...
    @property
    def Count(self) -> int: ...


class Solver:
    def Solve_Faces(nodes: Node2List, jitter_amount: float) -> List: ...
    def Solve_Mesh(nodes: Node2List, jitter_amount: float, faces: List) -> Tuple[Mesh, List]: ...
    def Solve_Connectivity(nodes: Node2List, jitter_amount: float, include_convex_hull_edges: bool) -> Connectivity: ...
